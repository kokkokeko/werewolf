
10月17日から技術調査をはじめました。コードは22、23日に書きました。
### ファイル、ディレクトリ説明
```bash
public/
  index.html
  main.js
  style.css
.gitignore
README.md
index.js
initializeSocket.js
package.json
```

1. public/ :ブラウザからリクエストが来たときにサーバから送られるファイルがある
2. public/index.html: ブラウザがURLのルートにアクセスしたときにサーバから送られるファイル
3. public/main.js: クライアント側のDOM描画、通信処理が記述されたjavascriptファイル
4. index.js: Express.jsサーバが記述されている
5. initializeSocket.js: サーバ側のsocket.ioを用いた処理とゲームロジックが記述されている
6. package.json: 今回使用したNode.jsの依存パッケージが記述されている。
### ファイル概要
#### サーバー側について
1. index.jsファイル：サーバ側のメインファイルであり、```$ npm start```で起動します。Express.jsフレームワークで2つの簡単なエンドポイントを作成しました。一つはブラウザがルートにアクセスしたときにpublic/index.htmlファイルを送信するものです。もう一つは[project-url]/entryです。レスポンスではNamespace(Socket.io用)の値を送信しそれを使ってクライアント側はSocket.ioの通信を初期化します。
2. initializeSocket.jsファイル: 1行目にてmodel.exportsにこのファイル全体を関数として設定し、index.jsファイル内でその関数を起動時に実行します。起動すると2、3行めでSocket.ioサーバを初期化します。5行目から16行目でglobal変数を初期化します。18行から129行まででゲームで使用するイベントを設置します。131行目から188行目までは使用する関数が記述されています。

#### ブラウザ側について
1. index.htmlファイル: 11行目に「通信を開始する」ボタンがあります。このボタンを押すとGET [project-url]/entry リクエストをサーバ側に送ります。12行目に今回のゲーム進行を表示するための要素ulがあります。
2. main.jsファイル: 2行目から11行目までで「通信を開始する」ボタンを押した時に使うイベントリスナを記述しています。13行から214行目まででDOMを使用してゲーム進行を表示していく関数を記述しています。215行から295行目まででSocket.ioクライアントを初期化、及びゲームで使用するイベントを設置しています。
### ファイル詳細
#### イベントemitting一覧
以下のように順番にイベントを発火していきます
| ブラウザ | サーバ |
| ------- | ------- |
| connection(ソケット初期化時) |  |
| disconnect(通信が切断された時) |  |
|  | someoneDisconnect(誰かの接続が切れた時) |
| submitPlayerName(名前を入力) | |
|  | preparePhaseGroup(役職を伝えます) |
|  | deniedByLimitation(参加者がすでに5人いる場合) |
| preparePhaseGroupEnd | dayPhaseDebate  |
| dayPhaseDebateEnd | dayPhaseVoting |
| dayPhaseVotingEnd | dayPhaseLynch | 
| dayPhaseLynchEnd | nightPhasePickTarget |
| nightPhasePickTargetEnd | dayPhaseKill |
| dayPhaseKillEnd | dayPhaseDebate |

#### ブラウザ側、main.js
##### 関数の説明
global変数のgameHistoryは今回のゲーム進行を表示するための要素ulのことです。ゲーム進行で使うボタンは死亡したプレイヤには表示されません。
1. entryGame: 「通信を開始する」ボタンのイベントリスナ。サーバからNamespace(Socket.io用)の値を受け取り、Socket.ioの通信を初期化します。
2. createHistory: 引数で受け取ったテキストをgameHistoryに追加します。
3. renderPlayers: 引数で受け取ったプレイヤーの状態をgameHistoryに追加します。
4. renderNextButton: ボタンを生成しgameHistoryに追加します。クリックイベント時に引数で受け取ったイベント名を発火します。
5. renderVoting: 処刑する人を投票で選ぶ時のラジオボタンを生成します。「誰も選ばない」ボタンがあります。自分自身及びすでに死亡しているプレイヤを選択できません。
6. renderVotingResult: 投票結果を表示します。
7. renderTarget: 人狼が殺害する人を選ぶ時のラジオボタンを生成します。自分自身及びすでに死亡しているプレイヤは選択できません。148行から156行で必ず殺害する人を1人選択させるような判定を記述しています。
8. renderKillResult: 殺害された人を表示
9. renderNameForm: ゲームに参加する時の名前を入力しボタンを押すとサーバへ送信します。必ず1文字以上入力するように制限します。
10. renderGameEnd: ゲーム終了時のプレイヤーの状態を表示します。役職も表示し誰が人狼だったか明らかになります。
11. initializeSocket: 引数で受け取ったNamespaceでSocket.ioクライアントを初期化します。
##### グローバル変数の説明
1. socket: 1001をNamespaceの値として使用したSocket.ioクライアントです。
2. gameHistory: ゲーム進行を表示するための要素ul。

#### サーバ側、initializeSocket.js
##### 関数の説明
1. decideLynchPersion: 処刑する人を決める投票の結果をPromiseで返します
2. initializeGame: ゲームで使用するプレイヤーの状態（players）を初期化します。人狼をランダムに選びます。
3. resetGlobalVariable: ゲーム中に通信が切断されたときにglobal変数を初期化して次のゲームができるようにします。
##### グローバル変数の説明
1. gameRoom: 1001をNamespaceの値として使用したSocket.ioサーバです。イベントを扱います。
2. countPlayer: 参加者数を制限します。
3. playerNames: socket.idとプレイヤー名のペアを格納した配列。今回の実装ではsocket.idをプレイヤーIDとして使います。
4. players: ゲームのプレイヤー状態を保持するオブジェクト。
5. count[イベント名]: 生存者からのイベント発火回数をカウントします。
6. totalAlive: 生存者数。5のカウントと比較し、生存者が全員進行ボタンを押したか確認します。
7. voting: 処刑する人を選ぶ時の投票を収集します。typeはオブジェクトですがハッシュテーブルとして使用しています。プレイヤーIDをキーとしたそれぞれのプレイヤーへの投票数をカウントしたオブジェクトです。
8. werewolfId: 人狼のIDです。人狼が生きているか判定するときに使います。
##### データ構造
```js
const players = {
  1001[ハッシュ値で表現されたID]: {
    name: 'takashi',
    isDead: false,
    group: 'villagers'
  },
  1001[ハッシュ値で表現されたID]: {
    name: 'matsuo',
    isDead: false,
    group: 'werewolf'
  },
  ...
}
```
### 問題点と頑張ったこと
1. ファイル整理、モジュールに分ける: フロントエンドについての描画ロジック（DOM）と通信ロジック（socket.io)、の分離、バックエンドについての通信ロジックとゲームロジックの分離ができるとコードの可読性や頭の整理ができると感じたが時間がなくできなかった。
2. 開発の進め方: フロントエンドとバックエンドを行き来しながらの開発だったので関心ごとが次々と入れ替わり頭の整理が追いつかなかった。フロントエンドとバックエンドを分離する。
2. テスト環境の重要性: 時間がなかったことからテスト環境設計ができなかった。それによりブラウザを直接操作する必要があったこと、ゲーム中盤の挙動を確認するまで時間がかかること、間違えたときに何度もやり直ししたことが手間だった。何をテストすべきか事前に設置し自動化する重要性を感じた。
5. ゲームステートの最良のデータ構造: コーディング前に考えたが、ゲーム全体の設計が把握できず利用しやすいデータ構造を作るまで時間がかかった。また、コーディングをしながら改良点がわかることがあり、設計時は大体のデータ構造を素早く考えコーディング中に改良するといいと感じた。また設計時はデータベースに保存するときに適したデータ構造と、ゲームで利用するときに好ましいデータ構造との違いでかなり混乱した。結局データベースは使用しなかった。
6. エラーと把握できない好ましくない挙動への対処、ログの大切さ: Socket.io、DOMに慣れるまで何度も把握できない挙動に見舞われた。基本知識を何度も読み直し、最小限の実装例を自分で書いて確認すると解決できることが多かった。慣れていないと時間がかかる。8:2の比率でアウトプット（考える）とインプット（調べる）ができるとコーディングスピードが上がり調子も良かった。調べることが多いと消化不良気味になった。エラーについてはログを細かく書くことで発見のスピードが上がった。
7. 忍耐力、体力: 時間がないこともあり、二日間続けて長時間コーディングをした。午後16時ごろになるとほとんど集中力がなかった。
8. ゲーム全体の設計と技術調査：技術に乏しくその設計が本当に実現可能なのかわからないことが多かった。コンピュータができることが何なのかを知るためにはOS、ネットワークの知識が不可欠であると調べながら感じた。DBとFile systemの違いや、リクエストを必要としないサーバからブラウザへ情報を送信する方法、ソケットアフィニティなど学ぶことが多かった。
9. 計画性:コードを書き始めるのが遅かった。最小限求められる実装を考え少しずつ機能を追加する。いきなりインフラやその他雑多な情報を先に読んでしまっていた。新しい技術を学ぶのにかかる時間、復習にかかる時間について見積もりができるといいと感じた。
7. この課題は何を測るものだったか: フロントエンドかロジックかインフラか通信技術かコーディング作法か、求められる知識が広範で大変だった。インフラについてはスケーリングするまでは進めなかった。
8. ドキュメントを読む技術: Socket.ioについて何ができるのかを把握するまで全体を読まないとわからなく、開発を始めるまでに時間がかかった。
9. 誰かの実装を見ないで自分の力で考える: 誰かが作った人狼ゲームのプロジェクトやチュートリアルを読まずに進めた。ゲームの仕様を解釈し、必要な技術が何なのかを自分で考え調べることができた。

#### 技術採用
開発中に学んだ技術：イベント処理を使った開発、Socket.io、DOM（半分は復習）、Express.js(復習)、Fetch API(復習)
1. クライアントのUI描画：Reactフレームワークに不慣れのため、簡単に復習できるネイティブDOM APIを採用した。
2. 通信：サーバーからクライアントへ送信する技術を調べた。使用経験があり、ドキュメントが読みやすいSocket.ioを採用した。
3. サーバ：簡単なエンドポイントを作れるのでExpress.jsを採用した。
4. データベース：時間がないため使用しなかった。ゲームは一時的にデータを使用するので今回はDBを使わなくても問題なかったが、複数のサーバアプリを立ち上げる場合、サーバ間でデータを共有するために必要だということが調べてわかった。
4. インフラ：使用経験のあるHerokuを使用した。